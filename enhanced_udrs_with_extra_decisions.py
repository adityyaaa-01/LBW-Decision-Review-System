# -*- coding: utf-8 -*-
"""Enhanced_UDRS_With_Extra_Decisions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18JBok3CeD9E2IMRKF-ksaCXXEIqPTV2M
"""

# Import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_curve, auc

# Generate synthetic DRS dataset
np.random.seed(42)
n_samples = 1000

data = pd.DataFrame({
    'impact_x': np.random.uniform(0, 10, n_samples),
    'impact_y': np.random.uniform(0, 22, n_samples),
    'angle': np.random.uniform(0, 90, n_samples),
    'stump_hit_prob': np.random.rand(n_samples),
    'bat_distance': np.random.uniform(0, 1, n_samples),
    'snick_peak': np.random.uniform(0, 1, n_samples),
    'umpire_decision': np.random.randint(0, 2, n_samples),
})

# Target variable: Review result
data['review_result'] = (
    (data['stump_hit_prob'] > 0.5).astype(int) ^
    data['umpire_decision']
)

# Features & Target
X = data.drop(columns='review_result')
y = data['review_result']

# Train/Test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Scale for SVM/Logistic
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Models
models = {
    'SVM': SVC(probability=True),
    'Decision Tree': DecisionTreeClassifier(),
    'Random Forest': RandomForestClassifier(),
    'Logistic Regression': LogisticRegression()
}

results = {}

# Train and evaluate
for name, model in models.items():
    X_fit = X_train_scaled if name in ['SVM', 'Logistic Regression'] else X_train
    X_eval = X_test_scaled if name in ['SVM', 'Logistic Regression'] else X_test

    model.fit(X_fit, y_train)
    y_pred = model.predict(X_eval)
    acc = accuracy_score(y_test, y_pred)
    results[name] = acc

    print(f"\n{name} Accuracy: {acc:.2f}")
    print(classification_report(y_test, y_pred))

    # Confusion matrix
    cm = confusion_matrix(y_test, y_pred)
    plt.figure(figsize=(4, 3))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f'{name} - Confusion Matrix')
    plt.xlabel("Predicted")
    plt.ylabel("Actual")
    plt.tight_layout()
    plt.show()

# ROC Curves
plt.figure(figsize=(8, 6))
for name, model in models.items():
    X_eval = X_test_scaled if name in ['SVM', 'Logistic Regression'] else X_test
    y_prob = model.predict_proba(X_eval)[:, 1]
    fpr, tpr, _ = roc_curve(y_test, y_prob)
    roc_auc = auc(fpr, tpr)
    plt.plot(fpr, tpr, label=f'{name} (AUC = {roc_auc:.2f})')

plt.plot([0, 1], [0, 1], 'k--')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.title("ROC Curve - DRS Models")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import pandas as pd
import numpy as np
# --- LBW Detection Logic ---
def detect_lbw(row):
    no_bat_contact = row['snick_peak'] < 0.2
    ball_would_hit_stumps = row['stump_hit_prob'] > 0.5
    impact_in_line = 3 < row['impact_x'] < 7  # Assuming 3-7 is the stumps line
    return int(no_bat_contact and ball_would_hit_stumps and impact_in_line)

data['is_lbw'] = data.apply(detect_lbw, axis=1)
print("Sample LBW decisions:\n", data[['impact_x', 'snick_peak', 'stump_hit_prob', 'is_lbw']].head())

import pandas as pd
import numpy as np
# --- No-Ball Detection Simulation ---
# Simulate foot landing position (0 to 1, where >0.6 is overstepping the crease)
np.random.seed(42)
data['foot_position'] = np.random.uniform(0, 1, len(data))
data['is_no_ball'] = (data['foot_position'] > 0.6).astype(int)

print("Sample No-Ball detections:\n", data[['foot_position', 'is_no_ball']].head())

import pandas as pd
import numpy as np
# --- Run-Out Detection Simulation ---
# Simulate bat inside crease (1) or outside (0) and bails removed (1 = removed)
np.random.seed(42)
data['bat_in_crease'] = np.random.randint(0, 2, len(data))
data['bails_removed'] = np.random.randint(0, 2, len(data))
data['is_run_out'] = ((data['bat_in_crease'] == 0) & (data['bails_removed'] == 1)).astype(int)

print("Sample Run-Out detections:\n", data[['bat_in_crease', 'bails_removed', 'is_run_out']].head())

import pandas as pd
import numpy as np
# --- Stumping Detection Simulation ---
np.random.seed(42)
data['foot_outside_crease'] = np.random.randint(0, 2, len(data))  # 1 = outside, 0 = inside
data['bails_removed_stump'] = np.random.randint(0, 2, len(data))  # 1 = removed
data['is_stumping'] = ((data['foot_outside_crease'] == 1) & (data['bails_removed_stump'] == 1)).astype(int)
print("Sample Stumping detections:\n", data[['foot_outside_crease', 'bails_removed_stump', 'is_stumping']].head())

# --- Catch Behind Detection Simulation ---
data['snick_detected'] = np.random.randint(0, 2, len(data))  # 1 = detected
data['caught_by_keeper'] = np.random.randint(0, 2, len(data))  # 1 = caught
data['is_catch_behind'] = ((data['snick_detected'] == 1) & (data['caught_by_keeper'] == 1)).astype(int)
print("Sample Catch Behind detections:\n", data[['snick_detected', 'caught_by_keeper', 'is_catch_behind']].head())

# --- Boundary Check Simulation ---
data['ball_distance_from_rope'] = np.random.uniform(-1, 5, len(data))  # in meters
data['is_boundary'] = (data['ball_distance_from_rope'] <= 0).astype(int)
print("Sample Boundary detections:\n", data[['ball_distance_from_rope', 'is_boundary']].head())

# --- No-Ball Above Waist Simulation ---
data['ball_height_at_batsman'] = np.random.uniform(0.5, 2.0, len(data))  # in meters
data['is_no_ball_waist'] = (data['ball_height_at_batsman'] > 1.2).astype(int)
print("Sample No-Ball (above waist) detections:\n", data[['ball_height_at_batsman', 'is_no_ball_waist']].head())

import cv2
import numpy as np
import matplotlib.pyplot as plt

video_path = "/content/(240) Could You Be a Cricket Umpire_ by The Times - YouTube - Google Chrome 2025-04-20 09-49-39-VEED.mp4"
cap = cv2.VideoCapture(video_path)

ball_positions = []
lower_red1 = np.array([0, 100, 100])
upper_red1 = np.array([10, 255, 255])
lower_red2 = np.array([160, 100, 100])
upper_red2 = np.array([180, 255, 255])

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    frame = cv2.resize(frame, (640, 360))
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
    mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
    mask = cv2.bitwise_or(mask1, mask2)

    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    if contours:
        largest_contour = max(contours, key=cv2.contourArea)
        if cv2.contourArea(largest_contour) > 10:
            (x, y), radius = cv2.minEnclosingCircle(largest_contour)
            ball_positions.append((int(x), int(y)))

cap.release()

if ball_positions:
    xs, ys = zip(*ball_positions)
    plt.figure(figsize=(10, 6))
    plt.plot(xs, ys, 'ro-', label="Ball Trajectory")
    plt.gca().invert_yaxis()
    plt.xlabel("X Position")
    plt.ylabel("Y Position")
    plt.title("Tracked Red Ball Trajectory")
    plt.legend()
    plt.grid(True)
    plt.show()

if ball_positions:
    import pandas as pd
    impact_x = np.mean(xs)
    impact_y = np.mean(ys)
    angle = np.arctan2(ys[-1] - ys[0], xs[-1] - xs[0]) * 180 / np.pi
    angle = abs(angle)

    features = pd.DataFrame([{
        'impact_x': impact_x / 640 * 10,
        'impact_y': impact_y / 360 * 22,
        'angle': angle,
        'stump_hit_prob': 0.7,
        'bat_distance': 0.1,
        'snick_peak': 0.05,
        'umpire_decision': 0
    }])

    # Use the Random Forest model for prediction:
    model = models['Random Forest']
    pred = model.predict(features)[0]
    verdict = "OUT" if pred == 1 else "NOT OUT"
    print(f"Model Verdict: {verdict}")
else:
    print("Cannot compute decision â€” no ball trajectory detected.")